  Essa prática versa sobre o funcionamento do sistema de inicialização de sistemas embarcados. Na Raspberry Pi, após o power on, se inicia um processo de bootloader que consiste em três estágios. O primeiro estágio inicializa a GPU e o arquivo bootcode.bin é buscado. Em seguida, a SDRAM é habilitada, o firmware da GPU é buscado e os periféricos são inicializados. Então, o firmware da GPU é carregado e executado, e o kernel Linux é carregado na RAM e executado na CPU. Após esses três estágios do bootloader, é executado o init system, responsável por carregar o sistema operacional. No caso da Raspberry Pi, o init system utilizado é o systemD. Ele é responsável por executar arquivos com extensão .service, que definem aplicativos que devem funcionar a partir do momento que a placa é ligada. Assim, nessa prática, será criado um arquivo .service de modo a adicionar um novo processo que deve ser executado pela Raspberry Pi assim que ela inicializa.
    Foi criado um arquivo denominado blink.py, que consiste no código a ser executado quando a Raspberry inicializa. Ainda, foi criado também o arquivo stopblink.py, que é executado quando ocorre o shutdown da placa. Eles consistem em códigos que fazem um LED externo à placa piscar a cada um segundo, e outro que para esse processo. O arquivo blink.service referencia os locais em que estão os códigos Python, e ele que é lido quando a Raspberry é ligada. Esse arquivo é colocado na pasta systemd/system, que contém todos os arquivos .service a serem executados quando a placa é ligada. A figura a seguir mostra o status do serviço blink em execução.

![scrotservice](https://github.com/user-attachments/assets/6edc7feb-0aa2-40c0-9ee7-38eea881ab97)
Também foi feita uma montagem em protoboard que conecta o pino de GPIO utilizado no código Python com um LED, por meio de um resistor. A figura a seguir ilustra essa mntagem funcionando com o código em execução.
![montagem](https://github.com/user-attachments/assets/cd84defd-62e0-4186-8a46-1f648fd5a9c0)
